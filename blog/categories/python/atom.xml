<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Trey Hunner]]></title>
  <link href="http://treyhunner.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://treyhunner.com/"/>
  <updated>2019-01-15T11:28:44-08:00</updated>
  <id>http://treyhunner.com/</id>
  <author>
    <name><![CDATA[Trey Hunner]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[No really, pathlib is great]]></title>
    <link href="http://treyhunner.com/2019/01/no-really-pathlib-is-great/"/>
    <updated>2019-01-15T11:20:00-08:00</updated>
    <id>http://treyhunner.com/2019/01/no-really-pathlib-is-great</id>
    <content type="html"><![CDATA[<p>I recently published an article about Python&rsquo;s <a href="https://docs.python.org/3/library/pathlib.html">pathlib</a> module and how I think everyone should be using it.</p>

<p>I won some <code>pathlib</code> converts, but some folks also brought up concerns.
Some folks noted that I seemed to be comparing <code>pathlib</code> to <code>os.path</code> in a disingenuous way.
Some people were also concerned that <code>pathlib</code> will take a very long time to be widely adopted because <code>os.path</code> is so entrenched in the Python community.
And there were also concerns expressed about performance.</p>

<p>In this article I&rsquo;d like to acknowledge and address these concerns.
This will be both a defense of <code>pathlib</code> and a love letter to <a href="https://www.python.org/dev/peps/pep-0519/#standard-library-changes">PEP 519</a>.</p>

<h2>Comparing pathlib and os.path the right way</h2>

<p>In my last article I compared this code which uses <code>os</code> and <code>os.path</code>:</p>

<pre><code class="python">import os
import os.path

os.makedirs(os.path.join('src', '__pypackages__'), exist_ok=True)
os.rename('.editorconfig', os.path.join('src', '.editorconfig'))
</code></pre>

<p>To this code with uses <code>pathlib.Path</code>:</p>

<pre><code class="python">from pathlib import Path

Path('src/__pypackages__').mkdir(parents=True, exist_ok=True)
Path('.editorconfig').rename('src/.editorconfig')
</code></pre>

<p>This might seem like an unfair comparison because I used <code>os.path.join</code> in the first example to ensure the correct path separator is used on all platforms but I didn&rsquo;t do that in the second example.
But this is in fact a fair comparison because <strong>the Path class normalizes path separators automatically</strong>.</p>

<p>We can prove this by looking at the string representation of this <code>Path</code> object on Windows:</p>

<pre><code class="pycon">&gt;&gt;&gt; str(Path('src/__pypackages__'))
'src\\__pypackages__'
</code></pre>

<p>No matter whether we use the <code>joinpath</code> method, a <code>/</code> in a path string, the <code>/</code> operator (which is a neat feature of <code>Path</code> objects), or separate arguments to the <code>Path</code> constructor, we get the same representation in all cases:</p>

<pre><code class="pycon">&gt;&gt;&gt; Path('src', '.editorconfig')
WindowsPath('src/.editorconfig')
&gt;&gt;&gt; Path('src') / '.editorconfig'
WindowsPath('src/.editorconfig')
&gt;&gt;&gt; Path('src').joinpath('.editorconfig')
WindowsPath('src/.editorconfig')
&gt;&gt;&gt; Path('src/.editorconfig')
WindowsPath('src/.editorconfig')
</code></pre>

<p>That last expression caused some confusion from folks who assumed <code>pathlib</code> wouldn&rsquo;t be smart enough to convert that <code>/</code> into a <code>\</code> in the path string.
Fortunately, it is!</p>

<p>With <code>Path</code> objects, you never have to worry about backslashes vs forward slashes again: specify all paths using forward slashes and you&rsquo;ll get what you&rsquo;d expect on all platforms.</p>

<h2>Normalizing file paths shouldn&rsquo;t be your concern</h2>

<p>If you&rsquo;re developing on Linux or Mac, it&rsquo;s very easy to add bugs to your code that only affect Windows users.
Unless you&rsquo;re careful to use <code>os.path.join</code> to build your paths up or <code>os.path.normcase</code> to convert forward slashes to backslashes as appropriate, <strong>you may be writing code that breaks on Windows</strong>.</p>

<p>This is a Windows bug waiting to happen (we&rsquo;ll get mixed backslashes and forward slashes here):</p>

<pre><code class="python">import sys
import os.path
directory = '.' if not sys.argv[1:] else sys.argv[1]
new_file = os.path.join(directory, 'new_package/__init__.py')
</code></pre>

<p>This just works on all systems:</p>

<pre><code class="python">import sys
from pathlib import Path
directory = '.' if not sys.argv[1:] else sys.argv[1]
new_file = Path(directory, 'new_package/__init__.py')
</code></pre>

<p>It used to be the responsibility of you the Python programmer to carefully join and normalize your paths, just as it used to be your responsibility in Python 2 land to use unicode whenever it was more appropriate than bytes.
This is the case no more.
The <code>pathlib.Path</code> class is careful to fix path separator issues before they even occur.</p>

<p>I don&rsquo;t use Windows.
I don&rsquo;t own a Windows machine.
But a ton of the developers who use my code likely use Windows and I don&rsquo;t want my code to break on their machines.</p>

<p><strong>If there&rsquo;s a chance that your Python code will ever run on a Windows machine, you really need <code>pathlib</code></strong>.</p>

<p><strong>Don&rsquo;t stress about path normalization</strong>: just use <code>pathlib.Path</code> whenever you need to represent a file path.</p>

<h2>pathlib seems great, but I depend on code that doesn&rsquo;t use it!</h2>

<p>You have lots of code that works with path strings.
Why would you switch to using <code>pathlib</code> when it means you&rsquo;d need to rewrite all this code?</p>

<p>Let&rsquo;s say you have a function like this:</p>

<pre><code class="python">import os
import os.path

def make_editorconfig(dir_path):
    """Create .editorconfig file in given directory and return filename."""
    filename = os.path.join(dir_path, '.editorconfig')
    if not os.path.exists(filename):
        os.makedirs(dir_path, exist_ok=True)
        open(filename, mode='wt').write('')
    return filename
</code></pre>

<p>This function accepts a directory to create a <code>.editorconfig</code> file in, like this:</p>

<pre><code class="pycon">&gt;&gt;&gt; import os.path
&gt;&gt;&gt; make_editorconfig(os.path.join('src', 'my_package'))
'src/my_package/.editorconfig'
</code></pre>

<p>But our code also works with a <code>Path</code> object:</p>

<pre><code class="pycon">&gt;&gt;&gt; from pathlib import Path
&gt;&gt;&gt; make_editorconfig(Path('src/my_package'))
'src/my_package/.editorconfig'
</code></pre>

<p>But&hellip; how??</p>

<p>Well <code>os.path.join</code> accepts <code>Path</code> objects (as of Python 3.6).
And <code>os.makedirs</code> accepts <code>Path</code> objects too.</p>

<p>In fact the built-in <code>open</code> function accepts <code>Path</code> objects and <code>shutil</code> does and anything in the standard library that previously accepted a <code>Path</code> object is now expected to work with both <code>Path</code> objects and path strings.</p>

<p>This is all thanks to <a href="https://www.python.org/dev/peps/pep-0519/#standard-library-changes">PEP 519</a>, which called for an <code>os.PathLike</code> abstract base class and declared that Python utilities that work with file paths should now accept either path strings or path-like objects.</p>

<h2>But my favorite third-party library X has a better Path object!</h2>

<p>You might already be using a third-party library that has a <code>Path</code> object which works differently than pathlib&rsquo;s Path objects.
Maybe you even like it better.</p>

<p>For example <a href="https://github.com/joke2k/django-environ">django-environ</a>, <a href="https://github.com/jaraco/path.py">path.py</a>, <a href="https://github.com/tomerfiliba/plumbum">plumbum</a>, and <a href="https://github.com/saulpw/visidata">visidata</a> all have their own custom <code>Path</code> objects that represent file paths.
Some of these <code>pathlib</code> alternatives predate <code>pathlib</code> and chose to inherit from <code>str</code> so they could be passed to functions that expected path strings.
Thanks to PEP 519 both <code>pathlib</code> and its third-party alternatives can play nicely without needing to resort to the hack of inheriting from <code>str</code>.</p>

<p>Let&rsquo;s say you don&rsquo;t like <code>pathlib</code> because <code>Path</code> objects are immutable and you very much prefer using mutable <code>Path</code> objects.
Well thanks to <a href="https://www.python.org/dev/peps/pep-0519/#standard-library-changes">PEP 519</a>, you can create your own even-better-because-it-is-mutable <code>Path</code> and also has a <code>__fspath__</code>.
You don&rsquo;t <em>need</em> to use <code>pathlib</code> to benefit from it.</p>

<p>Any homegrown <code>Path</code> object you make or find in a third party library now has the ability to work natively with the Python built-ins and standard library modules that expect Path objects.
<strong>Even if you don&rsquo;t like <code>pathlib</code>, its existence a big win for third-party <code>Path</code> objects as well</strong>.</p>

<h2>But Path objects and path strings don&rsquo;t mix, do they?</h2>

<p>You might be thinking: this is really wonderful, but won&rsquo;t this sometimes-a-string and sometimes-a-path-object situation add confusion to my code?</p>

<p>The answer is yes, somewhat.
But I&rsquo;ve found that it&rsquo;s pretty easy to work around.</p>

<p>PEP 519 added a couple other things along with path-like objects: one is a way to convert all path-like objects to path strings and the other is a way to convert all path-like objects to <code>Path</code> objects.</p>

<p>Given either a path string or a <code>Path</code> object (or anything with a <code>__fspath__</code> method):</p>

<pre><code class="python">from pathlib import Path
import os.path
p1 = os.path.join('src', 'my_package')
p2 = Path('src/my_package')
</code></pre>

<p>The <code>os.fspath</code> function will now normalize both of these types of paths to strings:</p>

<pre><code class="pycon">&gt;&gt;&gt; from os import fspath
&gt;&gt;&gt; fspath(p1), fspath(p2)
('src/my_package', 'src/my_package')
</code></pre>

<p>And the <code>Path</code> class will now accept both of these types of paths and convert them to <code>Path</code> objects:</p>

<pre><code class="pycon">&gt;&gt;&gt; Path(p1), Path(p2)
(PosixPath('src/my_package'), PosixPath('src/my_package'))
</code></pre>

<p>That means you could convert the output of the <code>make_editorconfig</code> function back into a <code>Path</code> object if you wanted to:</p>

<pre><code class="pycon">&gt;&gt;&gt; from pathlib import Path
&gt;&gt;&gt; Path(make_editorconfig(Path('src/my_package')))
PosixPath('src/my_package/.editorconfig')
</code></pre>

<p>Though of course a better long-term approach would be to rewrite the <code>make_editorconfig</code> function to use <code>pathlib</code> instead.</p>

<h2>pathlib is too slow</h2>

<p>I&rsquo;ve heard this concern come up a few times: <code>pathlib</code> is just too slow.</p>

<p>It&rsquo;s true that <code>pathlib</code> can be slow.
Creating thousands of <code>Path</code> objects can make a noticeable impact on your code.</p>

<p>I decided to test the performance difference between <code>pathlib</code> and the alternative on my own machine using two different programs that both look for all <code>.py</code> files below the current directory.</p>

<p>Here&rsquo;s the <code>os.walk</code> version:</p>

<pre><code class="python">from os import getcwd, walk


extension = '.py'
count = 0
for root, directories, filenames in walk(getcwd()):
    for filename in filenames:
        if filename.endswith(extension):
            count += 1
print(f"{count} Python files found")
</code></pre>

<p>Here&rsquo;s the <code>Path.rglob</code> version:</p>

<pre><code class="python">from pathlib import Path


extension = '.py'
count = 0
for filename in Path.cwd().rglob(f'*{extension}'):
    count += 1
print(f"{count} Python files found")
</code></pre>

<p>Testing runtimes for programs that rely on filesystem accesses is tricky because runtimes vary greatly, so I reran each script 10 times and compared the best runtime of each.</p>

<p>Both scripts found 97,507 Python files in the directory I ran them in.
The first one finished in 1.914 seconds (best out of 10 runs).
The second one finished in 3.430 seconds (best out of 10 runs).</p>

<p>When I set <code>extension = ''</code> these find about 600,000 files and the differences spread a little further apart.
The first runs in 1.888 seconds and the second in 7.485 seconds.</p>

<p>So the <code>pathlib</code> version of this program <strong>ran twice as slow</strong> for <code>.py</code> files and <strong>four times as slow</strong> for every file in my home directory.
<strong>The <code>pathlib</code> code was indeed slower</strong>, much slower percentage-wise.</p>

<p>But in my case, this speed difference doesn&rsquo;t matter much.
I searched for every file in my home directory and lost 6 seconds to the slower version of my code.
If I needed to scale this code to search 10 million files, I&rsquo;d probably want to rewrite it.
But that&rsquo;s a problem I can get to if I experience it.</p>

<p>If you have a tight loop that could use some optimizing and <code>pathlib.Path</code> is one of the bottlenecks that&rsquo;s slowing that loop down, abandon <code>pathlib</code> in that part of your code.
But <strong>don&rsquo;t optimize parts of your code that aren&rsquo;t bottlenecks</strong>: it&rsquo;s a waste of time and often results in less readable code for little gain.</p>

<h2>Improving readability with pathlib</h2>

<p>I&rsquo;d like to wrap up these thoughts by ending with some <code>pathlib</code> refactorings.
I&rsquo;ve taken a couple small examples of code that work with files and refactored these examples to use <code>pathlib</code> instead.
I&rsquo;ll mostly leave these code blocks without comment and let you be the judge of which versions you like best.</p>

<p>Here&rsquo;s the <code>make_editorconfig</code> function we saw earlier:</p>

<pre><code class="python">import os
import os.path


def make_editorconfig(dir_path):
    """Create .editorconfig file in given directory and return filename."""
    filename = os.path.join(dir_path, '.editorconfig')
    if not os.path.exists(filename):
        os.makedirs(dir_path, exist_ok=True)
        open(filename, mode='wt').write('')
    return filename
</code></pre>

<p>And here&rsquo;s the same function using <code>pathlib.Path</code> instead:</p>

<pre><code class="python">from pathlib import Path


def make_editorconfig(dir_path):
    """Create .editorconfig file in given directory and return filepath."""
    path = Path(dir_path, '.editorconfig')
    if not path.exists():
        path.parent.mkdir(exist_ok=True, parent=True)
        path.touch()
    return path
</code></pre>

<p>Here&rsquo;s a command-line program that accepts a string representing a directory and prints the contents of the <code>.gitignore</code> file in that directory if one exists:</p>

<pre><code class="python">import os.path
import sys


directory = sys.argv[1]
ignore_filename = os.path.join(directory, '.gitignore')
if os.path.isfile(ignore_filename):
    with open(ignore_filename, mode='rt') as ignore_file:
        print(ignore_file.read(), end='')
</code></pre>

<p>This is the same code using <code>pathlib.Path</code>:</p>

<pre><code class="python">from pathlib import Path
import sys


directory = Path(sys.argv[1])
ignore_path = directory / '.gitignore'
if ignore_path.is_file():
    print(ignore_path.read_text(), end='')
</code></pre>

<p>And here&rsquo;s some code that prints all groups of files in and below the current directory which are duplicates:</p>

<pre><code class="python">from collections import defaultdict
from hashlib import md5
from os import getcwd, walk
import os.path


def find_files(filepath):
    for root, directories, filenames in walk(filepath):
        for filename in filenames:
            yield os.path.join(root, filename)


file_hashes = defaultdict(list)
for path in find_files(getcwd()):
    with open(path, mode='rb') as my_file:
        file_hash = md5(my_file.read()).hexdigest()
        file_hashes[file_hash].append(path)

for paths in file_hashes.values():
    if len(paths) &gt; 1:
        print("Duplicate files found:")
        print(*paths, sep='\n')
</code></pre>

<p>This is the same code that uses <code>pathlib.Path</code> instead:</p>

<pre><code class="python">from collections import defaultdict
from hashlib import md5
from pathlib import Path


def find_files(filepath):
    for path in Path(filepath).rglob('*'):
        if path.is_file():
            yield path


file_hashes = defaultdict(list)
for path in find_files(Path.cwd()):
    file_hash = md5(path.read_bytes()).hexdigest()
    file_hashes[file_hash].append(path)

for paths in file_hashes.values():
    if len(paths) &gt; 1:
        print("Duplicate files found:")
        print(*paths, sep='\n')
</code></pre>

<p>The changes here are subtle, but I think they add up.
I prefer this <code>pathlib</code>-refactored version.</p>

<h2>Start using pathlib.Path objects</h2>

<p>Let&rsquo;s recap.</p>

<p>The <code>/</code> separators in <code>pathlib.Path</code> strings are automatically converted to the correct path separator based on the operating system you&rsquo;re on.
This is a huge feature that can make for code that is <strong>more readable and more certain to be free of path-related bugs</strong>.</p>

<pre><code class="pycon">&gt;&gt;&gt; path1 = Path('dir', 'file')
&gt;&gt;&gt; path2 = Path('dir') / 'file'
&gt;&gt;&gt; path3 = Path('dir/file')
&gt;&gt;&gt; path3
WindowsPath('dir/file')
&gt;&gt;&gt; path1 == path2 == path3
True
</code></pre>

<p>The Python standard library and built-ins (like <code>open</code>) also accept <code>pathlib.Path</code> objects now.
This means <strong>you can start using pathlib, even if your dependencies don&rsquo;t</strong>!</p>

<pre><code class="python">from shutil import move

def rename_and_redirect(old_filename, new_filename):
    move(old, new)
    with open(old, mode='wt') as f:
        f.write(f'This file has moved to {new}')
</code></pre>

<pre><code class="pycon">&gt;&gt;&gt; from pathlib import Path
&gt;&gt;&gt; old, new = Path('old.txt'), Path('new.txt')
&gt;&gt;&gt; rename_and_redirect(old, new)
&gt;&gt;&gt; old.read_text()
'This file has moved to new.txt'
</code></pre>

<p>And if you don&rsquo;t like <code>pathlib</code>, you can use a third-party library that provides the same path-like interface.
This is great because <strong>even if you&rsquo;re not a fan of <code>pathlib</code> you&rsquo;ll still benefit from the new changes detailed in PEP 519</strong>.</p>

<pre><code class="pycon">&gt;&gt;&gt; from plumbum import Path
&gt;&gt;&gt; my_path = Path('old.txt')
&gt;&gt;&gt; with open(my_path) as f:
...     print(f.read())
...
This file has moved to new.txt
</code></pre>

<p>While <code>pathlib</code> is sometimes slower than the alternative(s), the cases where this matters are somewhat rare (in my experience at least) and <strong>you can always jump back to using path strings for parts of your code that are particularly performance sensitive</strong>.</p>

<p>And in general, <code>pathlib</code> makes for more readable code.
Here&rsquo;s a succinct and descriptive Python script to demonstrate my point:</p>

<pre><code class="python">from pathlib import Path
gitignore = Path('.gitignore')
if gitignore.is_file():
    print(gitignore.read_text(), end='')
</code></pre>

<p>The <code>pathlib</code> module is lovely: start using it!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why you should be using pathlib]]></title>
    <link href="http://treyhunner.com/2018/12/why-you-should-be-using-pathlib/"/>
    <updated>2018-12-21T14:00:00-08:00</updated>
    <id>http://treyhunner.com/2018/12/why-you-should-be-using-pathlib</id>
    <content type="html"><![CDATA[<p>When I discovered Python&rsquo;s new <a href="https://docs.python.org/3/library/pathlib.html">pathlib</a> module a few years ago, I initially wrote it off as being a slightly more awkward and unnecessarily object-oriented version of the <code>os.path</code> module.
I was wrong.
Python&rsquo;s <code>pathlib</code> module is actually <a href="https://jefftriplett.com/2017/pathlib-is-wonderful/">wonderful</a>!</p>

<p>In this article I&rsquo;m going to try to sell you on <code>pathlib</code>.
I hope that this article will inspire you to <strong>use Python&rsquo;s <code>pathlib</code> module pretty much anytime you need to work with files in Python</strong>.</p>

<h2>os.path is clunky</h2>

<p>The <code>os.path</code> module has always been what we reached for to work with paths in Python.
It&rsquo;s got pretty much all you need, but it can be very clunky sometimes.</p>

<p>Should you import it like this?</p>

<pre><code class="python">import os.path

BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
TEMPLATES_DIR = os.path.join(BASE_DIR, 'templates')
</code></pre>

<p>Or like this?</p>

<pre><code class="python">from os.path import abspath, dirname, join

BASE_DIR = dirname(dirname(abspath(__file__)))
TEMPLATES_DIR = join(BASE_DIR, 'templates')
</code></pre>

<p>Or maybe that <code>join</code> function is too generically named&hellip; so we could do this instead:</p>

<pre><code class="python">from os.path import abspath, dirname, join as joinpath

BASE_DIR = dirname(dirname(abspath(__file__)))
TEMPLATES_DIR = joinpath(BASE_DIR, 'templates')
</code></pre>

<p>I find all of these a bit awkward.
We&rsquo;re passing strings into functions that return strings which we then pass into other functions that return strings.
All of these strings happen to represent paths, but they&rsquo;re still just strings.</p>

<p>The string-in-string-out functions in <code>os.path</code> are really awkward when nested because the code has to be read from the inside out.
Wouldn&rsquo;t it be nice if we could take these nested function calls and turn them into chained method calls instead?</p>

<p>With the <code>pathlib</code> module we can!</p>

<pre><code class="python">from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent
TEMPLATES_DIR = BASE_DIR.joinpath('templates')
</code></pre>

<p>The <code>os.path</code> module requires function nesting, but <strong>the <code>pathlib</code> modules&#8217; <code>Path</code> class allows us to chain methods and attributes</strong> on <code>Path</code> objects to get an equivalent path representation.</p>

<p>I know what you&rsquo;re thinking: wait these <code>Path</code> objects aren&rsquo;t the same thing: they&rsquo;re objects, not path strings!
I&rsquo;ll address that later (hint: these can pretty much be used interchangeably with path strings).</p>

<h2>The os module is crowded</h2>

<p>Python&rsquo;s classic <code>os.path</code> module is just for working with paths.
Once you want to actually <em>do</em> something with a path (e.g. create a directory) you&rsquo;ll need to reach for another Python module, often the <code>os</code> module.</p>

<p>The <code>os</code> module has lots of utilities for working with files and directories: <code>mkdir</code>, <code>getcwd</code>, <code>chmod</code>, <code>stat</code>, <code>remove</code>, <code>rename</code>, and <code>rmdir</code>.
Also <code>chdir</code>, <code>link</code>, <code>walk</code>, <code>listdir</code>, <code>makedirs</code>, <code>renames</code>, <code>removedirs</code>, <code>unlink</code> (same as <code>remove</code>), and <code>symlink</code>.
And a bunch of other stuff that isn&rsquo;t related to the filesystems at all: <code>fork</code>, <code>getenv</code>, <code>putenv</code>, <code>environ</code>, <code>getlogin</code>, and <code>system</code>.
Plus dozens of things I didn&rsquo;t mention in this paragraph.</p>

<p><strong>Python&rsquo;s <code>os</code> module does a little bit of everything; it&rsquo;s sort of a junk drawer for system-related stuff</strong>.
There&rsquo;s a lot of lovely stuff in the <code>os</code> module, but it can be hard to find what you&rsquo;re looking for sometimes:
if you&rsquo;re looking for path-related or filesystem-related things in the <code>os</code> module, you&rsquo;ll need to do a bit of digging.</p>

<p>The <code>pathlib</code> module replaces many of these filesystem-related <code>os</code> utilities with methods on the <code>Path</code> object.</p>

<p>Here&rsquo;s some code that makes a <code>src/__pypackages__</code> directory and renames our <code>.editorconfig</code> file to <code>src/.editorconfig</code>:</p>

<pre><code class="python">import os
import os.path

os.makedirs(os.path.join('src', '__pypackages__'), exist_ok=True)
os.rename('.editorconfig', os.path.join('src', '.editorconfig'))
</code></pre>

<p>This code does the same thing using <code>Path</code> objects:</p>

<pre><code class="python">from pathlib import Path

Path('src/__pypackages__').mkdir(parents=True, exist_ok=True)
Path('.editorconfig').rename('src/.editorconfig')
</code></pre>

<p>Notice that the <code>pathlib</code> code puts the path first because of method chaining!</p>

<p>As the Zen of Python says, &ldquo;namespaces are one honking great idea, let&rsquo;s do more of those&rdquo;.
The <code>os</code> module is a very large namespace with a bunch of stuff in it.
<strong>The pathlib.Path class is a much smaller and more specific namespace than the os module</strong>.
Plus the methods in this <code>Path</code> namespace return <code>Path</code> objects, which allows for method chaining instead of nested string-iful function calls.</p>

<h2>Don&rsquo;t forget about the glob module!</h2>

<p>The <code>os</code> and <code>os.path</code> modules aren&rsquo;t the only filepath/filesystem-related utilities in the Python standard library.
The <code>glob</code> module is another handy path-related module.</p>

<p>We can use the <code>glob.glob</code> function for finding files that match a certain pattern:</p>

<pre><code class="python">from glob import glob

top_level_csv_files = glob('*.csv')
all_csv_files = glob('**/*.csv', recursive=True)
</code></pre>

<p>The new <code>pathlib</code> module includes glob-like utilities as well.</p>

<pre><code class="python">from pathlib import Path

top_level_csv_files = Path.cwd().glob('*.csv')
all_csv_files = Path.cwd().rglob('*.csv')
</code></pre>

<p>After you&rsquo;ve started using <code>pathlib</code> more heavily, <strong>you can pretty much forget about the glob module entirely</strong>: you&rsquo;ve got all the glob functionality you need with <code>Path</code> objects.</p>

<h2>pathlib makes the simple cases simpler</h2>

<p>The <code>pathlib</code> module makes a number of complex cases somewhat simpler, but <strong>it also makes some of the simple cases even simpler</strong>.</p>

<p>Need to read all the text in one or more files?</p>

<p>You could open the file, read its contents and close the file using a <code>with</code> block:</p>

<pre><code class="python">from glob import glob

file_contents = []
for filename in glob('**/*.py', recursive=True):
    with open(filename) as python_file:
        file_contents.append(python_file.read())
</code></pre>

<p>Or you could use the <code>read_text</code> method on <code>Path</code> objects and a list comprehension to read the file contents into a new list all in one line:</p>

<pre><code class="python">from pathlib import Path

file_contents = [
    path.read_text()
    for path in Path.cwd().rglob('*.py')
]
</code></pre>

<p>What if you need to write to a file?</p>

<p>You could use the <code>open</code> context manager again:</p>

<pre><code class="python">with open('.editorconfig') as config:
    config.write('# config goes here')
</code></pre>

<p>Or you could use the <code>write_text</code> method:</p>

<pre><code class="python">Path('.editorconfig').write_text('# config goes here')
</code></pre>

<p>If you prefer using <code>open</code>, whether as a context manager or otherwise, you could instead use the <code>open</code> method on your <code>Path</code> object:</p>

<pre><code class="python">from pathlib import Path

path = Path('.editorconfig')
with path.open(mode='wt') as config:
    config.write('# config goes here')
</code></pre>

<p>Or, as of Python 3.6, you can even pass your <code>Path</code> object to the built-in <code>open</code> function:</p>

<pre><code class="python">from pathlib import Path

path = Path('.editorconfig')
with open(path, mode='wt') as config:
    config.write('# config goes here')
</code></pre>

<h2>Path objects make your code more explicit</h2>

<p>What do the following 3 variables point to?
What do their values represent?</p>

<pre><code class="python">person = '{"name": "Trey Hunner", "location": "San Diego"}'
pycon_2019 = "2019-05-01"
home_directory = '/home/trey'
</code></pre>

<p>Each of those variables points to a string.</p>

<p>Those strings represent different things: one is a JSON blob, one is a date, and one is a file path.</p>

<p>These are a little bit more useful representations for these objects:</p>

<pre><code class="python">from datetime import date
from pathlib import Path

person = {"name": "Trey Hunner", "location": "San Diego"}
pycon_2019 = date(2019, 5, 1)
home_directory = Path('/home/trey')
</code></pre>

<p>JSON objects deserialize to dictionaries, dates are represented natively using <code>datetime.date</code> objects, and <strong>filesystem paths can now be generically represented using <code>pathlib.Path</code> objects</strong>.</p>

<p>Using <code>Path</code> objects makes your code more explicit.
If you&rsquo;re trying to represent a date, you can use a <code>date</code> object.
If you&rsquo;re trying to represent a filepath, you can use a <code>Path</code> object.</p>

<p>I&rsquo;m not a strong advocate of object-oriented programming.
Classes add another layer of abstraction and abstractions can sometimes add more complexity than simplicity.
But the <code>pathlib.Path</code> class is <strong>a useful abstraction</strong>.
It&rsquo;s also quickly becoming a universally recognized abstraction.</p>

<p>Thanks to <a href="https://www.python.org/dev/peps/pep-0519/#standard-library-changes">PEP 519</a>, file path objects are now becoming the standard for working with paths.
As of Python 3.6, the built-in <code>open</code> function and the various functions in the <code>os</code>, <code>shutil</code>, and <code>os.path</code> modules all work properly with <code>pathlib.Path</code> objects.
<strong>You can start using pathlib today without changing most of your code that works with paths</strong>!</p>

<h2>What&rsquo;s missing from pathlib?</h2>

<p>While <code>pathlib</code> is great, it&rsquo;s not all-encompassing.
There are definitely <strong>a few missing features I&rsquo;ve stumbled upon that I wish the <code>pathlib</code> module included</strong>.</p>

<p>The first gap I&rsquo;ve noticed is the lack of <code>shutil</code> equivalents within the <code>pathlib.Path</code> methods.</p>

<p>While you can pass <code>Path</code> objects (and path-like objects) to the higher-level <code>shutil</code> functions for copying/deleting/moving files and directories, there&rsquo;s no equivalent to these functions on <code>Path</code> objects.</p>

<p>So to copy a file you still have to do something like this:</p>

<pre><code class="python">from pathlib import Path
from shutil import copyfile

source = Path('old_file.txt')
destination = Path('new_file.txt')
copyfile(source, destination)
</code></pre>

<p>There&rsquo;s also no <code>pathlib</code> equivalent of <code>os.chdir</code>.</p>

<p>This just means you&rsquo;ll need to import <code>chdir</code> if you ever need to change the current working directory:</p>

<pre><code class="python">from pathlib import Path
from os import chdir

parent = Path('..')
chdir(parent)
</code></pre>

<p>The <code>os.walk</code> function has no <code>pathlib</code> equivalent either.
Though you can make your own <code>walk</code>-like functions using <code>pathlib</code> fairly easily.</p>

<p>My hope is that <code>pathlib.Path</code> objects might eventually include methods for some of these missing operations.
But even with these missing features, <strong>I still find it much more manageable to use &ldquo;<code>pathlib</code> and friends&rdquo; than &ldquo;<code>os.path</code> and friends&rdquo;</strong>.</p>

<h2>Should you always use pathlib?</h2>

<p>Since Python 3.6, <strong>pathlib.Path objects work nearly everywhere you&rsquo;re already using path strings</strong>.
So I see no reason <em>not</em> to use <code>pathlib</code> if you&rsquo;re on Python 3.6 (or higher).</p>

<p>If you&rsquo;re on an earlier version of Python 3, you can always wrap your <code>Path</code> object in a <code>str</code> call to get a string out of it when you need an escape hatch back to string land.
It&rsquo;s awkward but it works:</p>

<pre><code class="python">from os import chdir
from pathlib import Path

chdir(Path('/home/trey'))  # Works on Python 3.6+
chdir(str(Path('/home/trey')))  # Works on earlier versions also
</code></pre>

<p>Regardless of which version of Python 3 you&rsquo;re on, I would recommend giving <code>pathlib</code> a try.</p>

<p>And if you&rsquo;re stuck on Python 2 still (the clock is ticking!) the third-party <a href="https://github.com/mcmtroffaes/pathlib2">pathlib2</a> module on PyPI is a backport so you can use <code>pathlib</code> on any version of Python.</p>

<p>I find that using <code>pathlib</code> often makes my code more readable.
Most of my code that works with files now defaults to using <code>pathlib</code> and I recommend that you do the same.
<strong>If you can use <code>pathlib</code>, you should</strong>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Cyber Monday Sales]]></title>
    <link href="http://treyhunner.com/2018/11/python-cyber-monday-sales/"/>
    <updated>2018-11-26T07:45:00-08:00</updated>
    <id>http://treyhunner.com/2018/11/python-cyber-monday-sales</id>
    <content type="html"><![CDATA[<p>I&rsquo;m running <a href="https://treyhunner.com/2018/11/python-morsels-sale-52-weeks-of-python/">a sale</a> that ends in 24 hours, but I&rsquo;m not the only one.
This post is a compilation of the different Cyber Monday deals I&rsquo;ve found related to Python and Python learning.</p>

<h3>Python Morsels weekly skill-building</h3>

<p>This is my weekly Python skill-building service.</p>

<p>I&rsquo;m offering 52 weeks of <a href="https://www.pythonmorsels.com/">Python Morsels</a> for 50% off.</p>

<p>You can find <a href="https://treyhunner.com/2018/11/python-morsels-sale-52-weeks-of-python/">more details on this sale here</a>.</p>

<h3>Talk Python Course Bundle</h3>

<p>Michael Kennedy of <a href="https://training.talkpython.fm/courses/bundle/black-friday-2018">Talk Python</a> is offering a 4 course bundle for a number of Python courses.</p>

<h3>Reuven Lerner&rsquo;s Python courses</h3>

<p>Reuven Lerner is also offering a <a href="http://blog.lerner.co.il/last-chance-to-save-40-on-python-and-git-courses/">40% off sale on his courses</a>.
Reuven has courses on Python, Git, and regular expressions.</p>

<h3>PyBites Code Challenges</h3>

<p>Bob and Julian of PyBites are offering a 50% off sale on their <a href="https://gumroad.com/l/ZFrD/black-friday">Code Challenges</a>.
These are a different variety of code challenges than Python Morsels.
You could sign up for both and <a href="https://www.pythonmorsels.com/">Python Morsels</a> if you wanted extra learning every week.</p>

<h3>Hello Web Books</h3>

<p>Tracy Osborn is running a 50% off sale on her <a href="https://hellowebbooks.com/order/">Hello Web Books</a>, which include books on Python and Django for beginners to web programming and books on design for beginners to web design.
You&rsquo;ll need to enter coupon code BLACKFRIDAY2018 to get these deals.</p>

<h3>The pytest book</h3>

<p>Brian Okken&rsquo;s <a href="https://pragprog.com/book/bopytest/python-testing-with-pytest">Python Testing with pytest</a> is on sale today (along with other Pragmatic Bookshelf books) for 40% off with coupon code turkeysale2018.</p>

<h3>More Python Books</h3>

<p>A number of Python book publishers, such as <a href="https://nostarch.com/catalog/python">No Starch</a>, are running big sales on their books.
I took a look at their sale, but haven&rsquo;t gone searching for more of them.</p>

<h3>Other Cyber Monday deals?</h3>

<p>If you have questions about the <a href="https://treyhunner.com/2018/11/python-morsels-sale-52-weeks-of-python/">Python Morsels sale</a>, <a href="mailto:tr%65y%40&amp;#116;%72%75&amp;#116;%68%66u&amp;#108;&amp;#46;&amp;#116;&amp;#101;c%68&amp;#110;%6flo%67%79">email me</a>.</p>

<p>The Python Morsels sale and likely all the other sales above will end in the next 24 hours, probably sooner depending on when you&rsquo;re reading this.</p>

<p>So go check them out!</p>

<p>Did I miss a deal that you know about?
Link to it in the comments!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Black Friday Sale: 50% Off 52 weeks of Python Morsels]]></title>
    <link href="http://treyhunner.com/2018/11/python-morsels-sale-52-weeks-of-python/"/>
    <updated>2018-11-21T11:00:00-08:00</updated>
    <id>http://treyhunner.com/2018/11/python-morsels-sale-52-weeks-of-python</id>
    <content type="html"><![CDATA[<p>I launched a weekly Python skill-building service earlier this year called <a href="https://www.pythonmorsels.com/">Python Morsels</a>.
This week I&rsquo;m running my first sale, which will also likely be the biggest sale that I run on Python Morsels for the foreseeable future (I don&rsquo;t want to say forever, but probably forever).</p>

<p>If you&rsquo;re an experienced programmer and you feel like your Python code could be <em>more Pythonic</em>, <a href="https://www.pythonmorsels.com/">Python Morsels</a> is for you.</p>

<p>Before I jump into details, let me explain what Python Morsels is.</p>

<h2>The inspiration</h2>

<p>I do on-site Python training for teams, which means I work with a lot of developers at a lot of companies.
One question I hear all the time is &ldquo;how can I make my code more Pythonic&rdquo;?</p>

<p>Most of the folks I teach are not new to programming and they&rsquo;re usually not new to Python either, but they also aren&rsquo;t experienced at leveraging the features and idioms that make Python unique.
Being a skilled programmer isn&rsquo;t the same as being a skilled <em>Python</em> programmer</p>

<p>Late last year this conundrum inspired me to create <a href="https://www.pythonmorsels.com/">Python Morsels</a>.</p>

<h2>Learning by doing</h2>

<p>My training courses and workshops are exercise-driven and I find an exercise-heavy style of teaching very effective.</p>

<p>You don&rsquo;t learn by putting information into your head, <strong>you learn by trying to retrieve information from your head</strong>.
You can watch talks and read books and read code, but you&rsquo;ll absorb very little unless you <em>apply</em> what you&rsquo;ve learned.
You learn by doing, which means writing Python code.</p>

<p>That&rsquo;s why Python Morsels is entirely about writing code and reflecting on the code you&rsquo;ve written.</p>

<h2>Python Morsels: exercise-driven learning</h2>

<p>After you sign up for Python Morsels I&rsquo;ll send you <strong>one exercise every week</strong>.
Not an interview questions: a realistic Python exercise inspired by the interesting problems I&rsquo;ve had to solve in the past. The purpose of these exercises is to <strong>inspire you to learn something new about Python each week</strong>.</p>

<p>Each exercise includes a number of bonuses so you can <strong>choose your own difficulty level</strong>.
All exercises also include automated tests so you can test your code quickly.
After you&rsquo;ve solved the exercise I&rsquo;ll send you a number of different solutions to the problem with a discussion about why we might choose one solution over another.
These solutions are meant to help you <strong>reconsider the way you write your code</strong>.</p>

<p>While solving the bonuses is important, the more important thing is that you <strong>get into the habit of time-boxed weekly learning</strong>. You want to spend your time effectively and the best way to do that is to <strong>form a learning habit</strong> and time box that habit.
I suggest that you dedicate 30 minutes every week to solving the exercise, regardless of the difficulty level you choose, as well as 30 minutes to reflecting on the solutions email I send you.</p>

<h2>So how much is this sale for?</h2>

<p>Python Morsels normally costs $16/month (or $160/year on the annual plan).</p>

<p>From now until Monday I&rsquo;m offering a 40% discount off the annual plan, which means you&rsquo;ll get <strong>52 weeks of Python skill-building for $96</strong>.
That&rsquo;s effectively $8/month or <strong>a 50% discount</strong> when compared to the monthly subscription.</p>

<p>I say &ldquo;52 weeks&rdquo; instead of 1 year because Python Morsels subscriptions can be &ldquo;paused&rdquo; at any time, which allows for breaks during vacations and busy periods and ensures you&rsquo;ll get all of the 52 weeks you signed up for.</p>

<p>To take advantage of this discount you&rsquo;ll need to sign up for <a href="https://www.pythonmorsels.com/">Python Morsels</a>, verify your email address, go to the Account page, and click the Subscribe button for the <strong>52 Week Plan</strong>.
The BLACKFRIDAY discount code should be automatically applied from now until the end of the sale on Monday.</p>

<h2>Money back guarantee</h2>

<p>This is the first sale I&rsquo;ve ever held so I&rsquo;m not sure whether it&rsquo;s common to offer a guarantee on sales, but I&rsquo;m going to do it for this one because I&rsquo;m pretty confident in what I&rsquo;m offering.</p>

<p>If you contact me with concerns but I can&rsquo;t find something that works for your needs, I&rsquo;ll send you a full refund.
I want you to improve your Python skills, but I don&rsquo;t want you signing up for something that isn&rsquo;t for you.
If you end up signing up for Python Morsels and you don&rsquo;t improve your Python skills because of it, <strong>you deserve a refund because I&rsquo;ve wasted your time</strong>.</p>

<h2>What do the first 52 weeks of Python Morsels exercises cover?</h2>

<p>Python Morsels starts small, but the exercises increase in difficulty over time.
The first 52 weeks of Python exercises will wander into <strong>a lot of interesting topics</strong>.</p>

<p>Within one year we&rsquo;ll:</p>

<ul>
<li>work with and create our own iterators (both generators and iterator classes)</li>
<li>make text-parsing programs and command-line programs</li>
<li>talk a lot about readability and code style</li>
<li>dive into a number of the built-ins and standard library modules</li>
<li>use operator overloading to make classes that support arithmetic</li>
<li>create our context managers</li>
<li>create our own decorators</li>
<li>use properties and descriptors and even <strong>make our own descriptor</strong></li>
<li>create custom collections (mappings, sequences, strings, sets, etc.)</li>
</ul>


<p>Haven&rsquo;t made a descriptor before?
By this time next year you will have!</p>

<h2>The sale ends on Monday</h2>

<p>This sale will ends on <strong>Monday November 26</strong>, end of day.</p>

<p>To get an effective 50% discount on Python Morsels over the next 52 weeks, <a href="https://www.pythonmorsels.com/signup/">sign up to Python Morsels</a>, verify your email, go to the Account page, and subscribe to the <strong>52 Week Plan</strong>.</p>

<h2>Share this sale with friends and family</h2>

<p>If you have a friend or colleague who might benefit from weekly Python practice, let them know about this sale!
The BLACKFRIDAY coupon expires on Monday, but there&rsquo;s no limit on the number of signups, so there&rsquo;s no reason to keep this sale a secret.</p>

<p>So please share this email or the discount code with anyone you know who might find value in 52 weeks of Python skill-building.</p>

<h2>Frequently Asked Questions</h2>

<p>These are questions that I&rsquo;ve been asked at least once (that&rsquo;s apparently what &ldquo;frequently&rdquo; means now).</p>

<h4>Is this for someone who is brand new to programming?</h4>

<p>No, it isn&rsquo;t.
Python Morsels is for someone who has been using Python for a while and wants to improve their Python coding practices.
Many of the folks currently signed up write primarily Python code, but have a background in at least one other programming language.
However, there are a handful of folks who are signed up who would call Python their first and only programming language and I do try to accommodate folks in that camp as much as I can.</p>

<p>In general, I recommend Python Morsels for <strong>folks who are currently writing Python code regularly</strong>.</p>

<h4>How is Python Morsels different from a Python course?</h4>

<p>During my on-site trainings I&rsquo;m present as a live instructor and coach.
That&rsquo;s something you won&rsquo;t get from Python Morsels.
During online courses there are videos explaining each topic before it&rsquo;s practiced.
Python Morsels also doesn&rsquo;t have that.</p>

<p>The focus of Python Morsels is a bit different than a course or a training.
If you think of Python course as like taking a tennis class, Python Morsels is more like <strong>weekly tennis practice</strong>.
A Python Morsels subscriber described it to me as <strong>like Hannon&rsquo;s finger exercises for piano or Kreutzer&rsquo;s études for violin</strong>.
Python Morsels is guided <strong>deliberate practice</strong> in the domain of writing readable and maintainable Python code.</p>

<h4>How much time does this require each week?</h4>

<p>I expect that you&rsquo;ll spend <strong>about an hour each week on Python Morsels in total</strong>.</p>

<p>You&rsquo;re a busy person who has production code to write and I don&rsquo;t want to waste your time.
The exercise includes bonuses, but I don&rsquo;t expect you to solve them all each week: instead I want you to time box yourself.
I recommend that you set aside 30 minutes to solve the problem each week, including running the tests and solving as many bonuses as you can.
I&rsquo;d also like you to set aside 30 minutes to reflect on your code while reading the solution email I send each week.
I often link to related resources to read/watch, but I&rsquo;d like you to bookmark those for later.</p>

<p>If you have more than one hour to devote each week, you could sit on the solutions for a couple days and then resolve the exercise without looking at the solutions email.
I don&rsquo;t expect this though.</p>

<h4>What if the exercises are too easy for me and I don&rsquo;t learn anything new?</h4>

<p>If you find the exercises are too easy, email me and I&rsquo;ll see what I can do.
I&rsquo;ve developed quite a few exercises over the last year and I may be able to work with you to ensure the exercises you get are a good fit for your experience level.
If it turns out that Python Morsels simply isn&rsquo;t for you, I&rsquo;ll refund you.</p>

<h4>What if the exercises suddenly get too hard for me?</h4>

<p>If the exercises turn out to be too challenging for you, either immediately or eventually, email me.
I plan to create some easier tracks for Python Morsels eventually (there&rsquo;s certainly demand for this) and I may have some suitable exercises to send to you.
If Python Morsels doesn&rsquo;t suit your needs and I can&rsquo;t easily fix the problem, I&rsquo;ll send you a refund.</p>

<h2>Ready to start a weekly skill-building habit?</h2>

<p>Are you ready to start 52 weeks of Python skill-building for $96 (normally $192)?
That&rsquo;s less than $2/week and about one hour of your time each week (which really is the bigger cost here).</p>

<p>If you have questions that I didn&rsquo;t address above, please <a href="mailto:tr%65y%40&amp;#116;%72%75&amp;#116;%68%66u&amp;#108;&amp;#46;&amp;#116;&amp;#101;c%68&amp;#110;%6flo%67%79">email me</a> and say what you&rsquo;re thinking/feeling.</p>

<p>If you&rsquo;re interested in seeing the opinion of someone who has worked through Python Morsels exercises, see the testimonials <a href="https://www.pythonmorsels.com/">on the homepage</a> or take a look at what some of my Python Morsels friends have said about it on Twitter (<a href="https://twitter.com/AndrewsForge/status/1018597131496710144">Andrew Pinkham</a>, <a href="https://twitter.com/PavelAnni/status/963778202605932544">Pavel Anni</a>, <a href="https://twitter.com/jmwatt3/status/1035314897280794629">Jason Wattier</a>, <a href="https://twitter.com/abqpythonista/status/976202006405595136">Ben Jones</a>).</p>

<p>Ready to sign up?
<a href="https://www.pythonmorsels.com/signup/">Click here to get 52 weeks of Python Morsels at 50% off</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Asterisks in Python: what they are and how to use them]]></title>
    <link href="http://treyhunner.com/2018/10/asterisks-in-python-what-they-are-and-how-to-use-them/"/>
    <updated>2018-10-11T07:30:00-07:00</updated>
    <id>http://treyhunner.com/2018/10/asterisks-in-python-what-they-are-and-how-to-use-them</id>
    <content type="html"><![CDATA[<p>There are a lot of places you&rsquo;ll see <code>*</code> and <code>**</code> used in Python.
These two operators can be a bit mysterious at times, both for brand new programmers and for folks moving from many other programming languages which may not have completely equivalent operators.
I&rsquo;d like to discuss what those operators are and the many ways they&rsquo;re used.</p>

<p>The <code>*</code> and <code>**</code> operators have grown in ability over the years and I&rsquo;ll be discussing all the ways that you can currently use these operators and noting which uses only work in modern versions of Python.
So if you learned <code>*</code> and <code>**</code> back in the days of Python 2, I&rsquo;d recommend at least skimming this article because Python 3 has added a lot of new uses for these operators.</p>

<p>If you&rsquo;re newer to Python and you&rsquo;re not yet familiar with keyword arguments (a.k.a. named arguments), I&rsquo;d recommend reading my article on <a href="https://treyhunner.com/2018/04/keyword-arguments-in-python/">keyword arguments in Python</a> first.</p>

<h2>What we&rsquo;re not talking about</h2>

<p>When I discuss <code>*</code> and <code>**</code> in this article, I&rsquo;m talking about the <code>*</code> and <code>**</code> <em>prefix</em> operators, not the <em>infix</em> operators.</p>

<p>So I&rsquo;m not talking about multiplication and exponentiation:</p>

<pre><code class="pycon">&gt;&gt;&gt; 2 * 5
10
&gt;&gt;&gt; 2 ** 5
32
</code></pre>

<h2>So what are we talking about?</h2>

<p>We&rsquo;re talking about the <code>*</code> and <code>**</code> prefix operators, that is the <code>*</code> and <code>**</code> operators that are used before a variable.  For example:</p>

<pre><code class="python">&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7]
&gt;&gt;&gt; more_numbers = [*numbers, 11, 18]
&gt;&gt;&gt; print(*more_numbers, sep=', ')
2, 1, 3, 4, 7, 11, 18
</code></pre>

<p>Two of the uses of <code>*</code> are shown in that code and no uses of <code>**</code> are shown.</p>

<p>This includes:</p>

<ol>
<li>Using <code>*</code> and <code>**</code> to pass arguments to a function</li>
<li>Using <code>*</code> and <code>**</code> to capture arguments passed into a function</li>
<li>Using <code>*</code> to accept keyword-only arguments</li>
<li>Using <code>*</code> to capture items during tuple unpacking</li>
<li>Using <code>*</code> to unpack iterables into a list/tuple</li>
<li>Using <code>**</code> to unpack dictionaries into other dictionaries</li>
</ol>


<p>Even if you think you&rsquo;re familiar with all of these ways of using <code>*</code> and <code>**</code>, I recommend looking at each of the code blocks below to make sure they&rsquo;re all things you&rsquo;re familiar with.
The Python core developers have continued to add new abilities to these operators over the last few years and it&rsquo;s easy to overlook some of the newer uses of <code>*</code> and <code>**</code>.</p>

<h2>Asterisks for unpacking into function call</h2>

<p>When calling a function, the <code>*</code> operator can be used to unpack an iterable into the arguments in the function call:</p>

<pre><code class="pycon">&gt;&gt;&gt; fruits = ['lemon', 'pear', 'watermelon', 'tomato']
&gt;&gt;&gt; print(fruits[0], fruits[1], fruits[2], fruits[3])
lemon pear watermelon tomato
&gt;&gt;&gt; print(*fruits)
lemon pear watermelon tomato
</code></pre>

<p>That <code>print(*fruits)</code> line is passing all of the items in the <code>fruits</code> list into the <code>print</code> function call as separate arguments, without us even needing to know how many arguments are in the list.</p>

<p>The <code>*</code> operator isn&rsquo;t just syntactic sugar here.
This ability of sending in all items in a particular iterable as separate arguments wouldn&rsquo;t be possible without <code>*</code>, unless the list was a fixed length.</p>

<p>Here&rsquo;s another example:</p>

<pre><code class="python">def transpose_list(list_of_lists):
    return [
        list(row)
        for row in zip(*list_of_lists)
    ]
</code></pre>

<p>Here we&rsquo;re accepting a list of lists and returning a &ldquo;transposed&rdquo; list of lists.</p>

<pre><code class="pycon">&gt;&gt;&gt; transpose_list([[1, 4, 7], [2, 5, 8], [3, 6, 9]])
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
</code></pre>

<p>The <code>**</code> operator does something similar, but with keyword arguments.
The <code>**</code> operator allows us to take a dictionary of key-value pairs and unpack it into keyword arguments in a function call.</p>

<pre><code class="pycon">&gt;&gt;&gt; date_info = {'year': "2020", 'month': "01", 'day': "01"}
&gt;&gt;&gt; filename = "{year}-{month}-{day}.txt".format(**date_info)
&gt;&gt;&gt; filename
'2020-01-01.txt'
</code></pre>

<p>From my experience, using <code>**</code> to unpack keyword arguments into a function call isn&rsquo;t particularly common.
The place I see this most is when practicing inheritance: calls to <code>super()</code> often include both <code>*</code> and <code>**</code>.</p>

<p>Both <code>*</code> and <code>**</code> can be used multiple times in function calls, as of Python 3.5.</p>

<p>Using <code>*</code> multiple times can sometimes be handy:</p>

<pre><code class="pycon">&gt;&gt;&gt; fruits = ['lemon', 'pear', 'watermelon', 'tomato']
&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7]
&gt;&gt;&gt; print(*numbers, *fruits)
2 1 3 4 7 lemon pear watermelon tomato
</code></pre>

<p>Using <code>**</code> multiple times looks similar:</p>

<pre><code class="pycon">&gt;&gt;&gt; date_info = {'year': "2020", 'month': "01", 'day': "01"}
&gt;&gt;&gt; track_info = {'artist': "Beethoven", 'title': 'Symphony No 5'}
&gt;&gt;&gt; filename = "{year}-{month}-{day}-{artist}-{title}.txt".format(
...     **date_info,
...     **track_info,
... )
&gt;&gt;&gt; filename
'2020-01-01-Beethoven-Symphony No 5.txt'
</code></pre>

<p>You need to be careful when using <code>**</code> multiple times though.
Functions in Python can&rsquo;t have the same keyword argument specified multiple times, so the keys in each dictionary used with <code>**</code> must be distinct or an exception will be raised.</p>

<h2>Asterisks for packing arguments given to function</h2>

<p>When defining a function, the <code>*</code> operator can be used to capture an unlimited number of positional arguments given to the function.
These arguments are captured into a tuple.</p>

<pre><code class="python">from random import randint

def roll(*dice):
    return sum(randint(1, die) for die in dice)
</code></pre>

<p>This function accepts any number of arguments:</p>

<pre><code class="pycon">&gt;&gt;&gt; roll(20)
18
&gt;&gt;&gt; roll(6, 6)
9
&gt;&gt;&gt; roll(6, 6, 6)
8
</code></pre>

<p>Python&rsquo;s <code>print</code> and <code>zip</code> functions accept any number of positional arguments.
This argument-packing use of <code>*</code> allows us to make our own function which, like <code>print</code> and <code>zip</code>, accept any number of arguments.</p>

<p>The <code>**</code> operator also has another side to it: we can use <code>**</code> when defining a function to capture any keyword arguments given to the function into a dictionary:</p>

<pre><code class="python">def tag(tag_name, **attributes):
    attribute_list = [
        f'{name}="{value}"'
        for name, value in attributes.items()
    ]
    return f"&lt;{tag_name} {' '.join(attribute_list)}&gt;"
</code></pre>

<p>That <code>**</code> will capture any keyword arguments we give to this function into a dictionary which will that <code>attributes</code> arguments will reference.</p>

<pre><code class="pycon">&gt;&gt;&gt; tag('a', href="http://treyhunner.com")
'&lt;a href="http://treyhunner.com"&gt;'
&gt;&gt;&gt; tag('img', height=20, width=40, src="face.jpg")
'&lt;img height="20" width="40" src="face.jpg"&gt;'
</code></pre>

<h2>Positional arguments with keyword-only arguments</h2>

<p>As of Python 3, we now have a special syntax for accepting keyword-only arguments to functions.
Keyword-only arguments are function arguments which can <em>only</em> be specified using the keyword syntax, meaning they cannot be specified positionally.</p>

<p>To accept keyword-only arguments, we can put named arguments after a <code>*</code> usage when defining our function:</p>

<pre><code class="python">def get_multiple(*keys, dictionary, default=None):
    return [
        dictionary.get(key, default)
        for key in keys
    ]
</code></pre>

<p>The above function can be used like this:</p>

<pre><code class="pycon">&gt;&gt;&gt; fruits = {'lemon': 'yellow', 'orange': 'orange', 'tomato': 'red'}
&gt;&gt;&gt; get_multiple('lemon', 'tomato', 'squash', dictionary=fruits, default='unknown')
['yellow', 'red', 'unknown']
</code></pre>

<p>The arguments <code>dictionary</code> and <code>default</code> come after <code>*keys</code>, which means they can <em>only</em> be specified as <a href="https://treyhunner.com/2018/04/keyword-arguments-in-python/">keyword arguments</a>.
If we try to specify them positionally we&rsquo;ll get an error:</p>

<pre><code class="pycon">&gt;&gt;&gt; fruits = {'lemon': 'yellow', 'orange': 'orange', 'tomato': 'red'}
&gt;&gt;&gt; get_multiple('lemon', 'tomato', 'squash', fruits, 'unknown')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: get_multiple() missing 1 required keyword-only argument: 'dictionary'
</code></pre>

<p>This behavior was introduced to Python through <a href="https://www.python.org/dev/peps/pep-3102/">PEP 3102</a>.</p>

<h2>Keyword-only arguments without positional arguments</h2>

<p>That keyword-only argument feature is cool, but what if you want to require keyword-only arguments without capturing unlimited positional arguments?</p>

<p>Python allows this with a somewhat strange <code>*</code>-on-its-own syntax:</p>

<pre><code class="python">def with_previous(iterable, *, fillvalue=None):
    """Yield each iterable item along with the item before it."""
    previous = fillvalue
    for item in iterable:
        yield previous, item
        previous = item
</code></pre>

<p>This function accepts an <code>iterable</code> argument, which can be specified positionally (as the first argument) or by its name and a <code>fillvalue</code> argument which is a keyword-only argument.  This means we can call <code>with_previous</code> like this:</p>

<pre><code class="pycon">&gt;&gt;&gt; list(with_previous([2, 1, 3], fillvalue=0))
[(0, 2), (2, 1), (1, 3)]
</code></pre>

<p>But not like this:</p>

<pre><code class="pycon">&gt;&gt;&gt; list(with_previous([2, 1, 3], 0))
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: with_previous() takes 1 positional argument but 2 were given
</code></pre>

<p>This function accepts two arguments and one of them, <code>fillvalue</code> <em>must be specified as a keyword argument</em>.</p>

<p>I usually use keyword-only arguments used while capturing any number of positional arguments, but I do sometimes use this <code>*</code> to enforce an argument to only be specified positionally.</p>

<p>Python&rsquo;s built-in <code>sorted</code> function actually uses this approach.  If you look at the help information on <code>sorted</code> you&rsquo;ll see the following:</p>

<pre><code>&gt;&gt;&gt; help(sorted)
Help on built-in function sorted in module builtins:

sorted(iterable, /, *, key=None, reverse=False)
    Return a new list containing all items from the iterable in ascending order.

    A custom key function can be supplied to customize the sort order, and the
    reverse flag can be set to request the result in descending order.
</code></pre>

<p>There&rsquo;s an <code>*</code>-on-its-own, right in the documented arguments for <code>sorted</code>.</p>

<h2>Asterisks in tuple unpacking</h2>

<p>Python 3 also added a new way of using the <code>*</code> operator that is only somewhat related to the <code>*</code>-when-defining-a-function and <code>*</code>-when-calling-a-function features above.</p>

<p>The <code>*</code> operator can also be used in tuple unpacking now:</p>

<pre><code class="pycon">&gt;&gt;&gt; fruits = ['lemon', 'pear', 'watermelon', 'tomato']
&gt;&gt;&gt; first, second, *remaining = fruits
&gt;&gt;&gt; remaining
['watermelon', 'tomato']
&gt;&gt;&gt; first, *remaining = fruits
&gt;&gt;&gt; remaining
['pear', 'watermelon', 'tomato']
&gt;&gt;&gt; first, *middle, last = fruits
&gt;&gt;&gt; middle
['pear', 'watermelon']
</code></pre>

<p>If you&rsquo;re wondering &ldquo;where could I use this in my own code&rdquo;, take a look at the examples in my article on <a href="https://treyhunner.com/2018/03/tuple-unpacking-improves-python-code-readability/">tuple unpacking in Python</a>.
In that article I show how this use of the <code>*</code> operator can sometimes be used as an alternative to sequence slicing.</p>

<p>Usually when I teach <code>*</code> I note that you can only use one <code>*</code> expression in a single multiple assignment call.
That&rsquo;s technically incorrect because it&rsquo;s possible to use two in a nested unpacking (I talk about nested unpacking in my tuple unpacking article):</p>

<pre><code class="pycon">&gt;&gt;&gt; fruits = ['lemon', 'pear', 'watermelon', 'tomato']
&gt;&gt;&gt; ((first_letter, *remaining), *other_fruits) = fruits
&gt;&gt;&gt; remaining
['e', 'm', 'o', 'n']
&gt;&gt;&gt; other_fruits
['pear', 'watermelon', 'tomato']
</code></pre>

<p>I&rsquo;ve never seen a good use for this though and I don&rsquo;t think I&rsquo;d recommend using it even if you found one because it seems a bit cryptic.</p>

<p>The PEP that added this to Python 3.0 is <a href="https://www.python.org/dev/peps/pep-3132/">PEP 3132</a> and it&rsquo;s not a very long one.</p>

<h2>Asterisks in list literals</h2>

<p>Python 3.5 introduced a ton of new <code>*</code>-related features through <a href="https://www.python.org/dev/peps/pep-0448/">PEP 448</a>.
One of the biggest new features is the ability to use <code>*</code> to dump an iterable into a new list.</p>

<p>Say you have a function that takes any sequence and returns a list with the sequence and the reverse of that sequence concatenated together:</p>

<pre><code class="python">def palindromify(sequence):
    return list(sequence) + list(reversed(sequence))
</code></pre>

<p>This function needs to convert things to lists a couple times in order to concatenate the lists and return the result.
In Python 3.5, we can type this instead:</p>

<pre><code class="python">def palindromify(sequence):
    return [*sequence, *reversed(sequence)]
</code></pre>

<p>This code removes some needless list calls so our code is both more efficient and more readable.</p>

<p>Here&rsquo;s another example:</p>

<pre><code class="python">def rotate_first_item(sequence):
    return [*sequence[1:], sequence[0]]
</code></pre>

<p>That function returns a new list where the first item in the given list (or other sequence) is moved to the end of the new list.</p>

<p>This use of the <code>*</code> operator is a great way to concatenate iterables of different types together.
The <code>*</code> operator works for any iterable, whereas using the <code>+</code> operator only works on particular sequences which have to all be the same type.</p>

<p>This isn&rsquo;t just limited to creating lists either.
We can also dump iterables into new tuples or sets:</p>

<pre><code class="pycon">&gt;&gt;&gt; fruits = ['lemon', 'pear', 'watermelon', 'tomato']
&gt;&gt;&gt; (*fruits[1:], fruits[0])
('pear', 'watermelon', 'tomato', 'lemon')
&gt;&gt;&gt; uppercase_fruits = (f.upper() for f in fruits)
&gt;&gt;&gt; {*fruits, *uppercase_fruits}
{'lemon', 'watermelon', 'TOMATO', 'LEMON', 'PEAR', 'WATERMELON', 'tomato', 'pear'}
</code></pre>

<p>Notice that the last line above takes a list and a generator and dumps them into a new set.
Before this use of <code>*</code>, there wasn&rsquo;t previously an easy way to do this in one line of code.
There was a way to do this before, but it wasn&rsquo;t easy to remember or discover:</p>

<pre><code class="pycon">&gt;&gt;&gt; set().union(fruits, uppercase_fruits)
{'lemon', 'watermelon', 'TOMATO', 'LEMON', 'PEAR', 'WATERMELON', 'tomato', 'pear'}
</code></pre>

<h2>Double asterisks in dictionary literals</h2>

<p>PEP 448 also expanded the abilities of <code>**</code> by allowing this operator to be used for dumping key/value pairs from one dictionary into a new dictionary:</p>

<pre><code class="pycon">&gt;&gt;&gt; date_info = {'year': "2020", 'month': "01", 'day': "01"}
&gt;&gt;&gt; track_info = {'artist': "Beethoven", 'title': 'Symphony No 5'}
&gt;&gt;&gt; all_info = {**date_info, **track_info}
&gt;&gt;&gt; all_info
{'year': '2020', 'month': '01', 'day': '01', 'artist': 'Beethoven', 'title': 'Symphony No 5'}
</code></pre>

<p>I wrote another article on how this is now the <a href="https://treyhunner.com/2016/02/how-to-merge-dictionaries-in-python/">idiomatic way to merge dictionaries in Python</a>.</p>

<p>This can be used for more than just merging two dictionaries together though.</p>

<p>For example we can copy a dictionary while adding a new value to it:</p>

<pre><code class="pycon">&gt;&gt;&gt; date_info = {'year': '2020', 'month': '01', 'day': '7'}
&gt;&gt;&gt; event_info = {**date_info, 'group': "Python Meetup"}
&gt;&gt;&gt; event_info
{'year': '2020', 'month': '01', 'day': '7', 'group': 'Python Meetup'}
</code></pre>

<p>Or copy/merge dictionaries while overriding particular values:</p>

<pre><code class="pycon">&gt;&gt;&gt; event_info = {'year': '2020', 'month': '01', 'day': '7', 'group': 'Python Meetup'}
&gt;&gt;&gt; new_info = {**event_info, 'day': "14"}
&gt;&gt;&gt; new_info
{'year': '2020', 'month': '01', 'day': '14', 'group': 'Python Meetup'}
</code></pre>

<h2>Python&rsquo;s asterisks are powerful</h2>

<p>Python&rsquo;s <code>*</code> and <code>**</code> operators aren&rsquo;t just syntactic sugar.
Some of the things they allow you to do could be achieved through other means, but the alternatives to <code>*</code> and <code>**</code> tend to be more cumbersome and more resource intensive.
And some of the features they provide are simply impossible to achieve without them: for example there&rsquo;s no way to accept any number of positional arguments to a function without <code>*</code>.</p>

<p>After reading about all the features of <code>*</code> and <code>**</code>, you might be wondering what the names for these odd operators are.
Unfortunately, they don&rsquo;t really have succinct names.
I&rsquo;ve heard <code>*</code> called the &ldquo;packing&rdquo; and &ldquo;unpacking&rdquo; operator.
I&rsquo;ve also heard it called &ldquo;splat&rdquo; (from the Ruby world) and I&rsquo;ve heard it called simply &ldquo;star&rdquo;.</p>

<p>I tend to call these operators &ldquo;star&rdquo; and &ldquo;double star&rdquo; or &ldquo;star star&rdquo;.
That doesn&rsquo;t distinguish them from their infix relatives (multiplication and exponentiation), but context usually makes it obvious whether we&rsquo;re talking about prefix or infix operators.</p>

<p>If you don&rsquo;t understand <code>*</code> and <code>**</code> or you&rsquo;re concerned about memorizing all of their uses, don&rsquo;t be!
These operators have many uses and memorizing the specific use of each one isn&rsquo;t as important as getting a feel for when you might be able to reach for these operators.
I suggest using this article as <strong>a cheat sheet</strong> or to making your own cheat sheet to help you use <code>*</code> and <code>**</code> in Python.</p>

<h2>Practice makes perfect</h2>

<p>You don&rsquo;t learn by putting information in your head, you learn by attempting to retrieve information from your head.
So you&rsquo;ve just read an article on something new, but <strong>you haven&rsquo;t learned yet</strong>.</p>

<p>Write some code that uses <code>*</code> and <code>**</code> in a number of different ways today.
Then quiz yourself on the many different ways to use <code>*</code> and <code>**</code> tomorrow!</p>

<p>If you&rsquo;d like to get practice with <code>*</code> and <code>**</code>, <strong><a href="https://www.pythonmorsels.com/">sign up for Python Morsels</a></strong>.
The first few problems use <code>*</code> in a couple different ways.
If you sign up for <a href="https://www.pythonmorsels.com/">Python Morsels</a> I&rsquo;ll help you <strong>level up your Python skills every week</strong>.</p>
]]></content>
  </entry>
  
</feed>
